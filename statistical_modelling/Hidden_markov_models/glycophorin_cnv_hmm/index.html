<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper docs-doc-page docs-version-current plugin-docs plugin-id-default docs-doc-id-statistical_modelling/Hidden_markov_models/glycophorin_cnv_hmm">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.20">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><title data-rh="true">Modelling CNVs using a Hidden Markov Model | The WHG training resources</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://well.ox.ac.uk//whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_hmm/"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Modelling CNVs using a Hidden Markov Model | The WHG training resources"><meta data-rh="true" name="description" content="!! Note !!  To run this part of the practical, you first need to have computed a set of log-likelihoods for"><meta data-rh="true" property="og:description" content="!! Note !!  To run this part of the practical, you first need to have computed a set of log-likelihoods for"><link data-rh="true" rel="icon" href="/whg-training-resources/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://well.ox.ac.uk//whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_hmm/"><link data-rh="true" rel="alternate" href="https://well.ox.ac.uk//whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_hmm/" hreflang="en"><link data-rh="true" rel="alternate" href="https://well.ox.ac.uk//whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_hmm/" hreflang="x-default"><link rel="stylesheet" href="/whg-training-resources/assets/css/styles.f24e0b7d.css">
<link rel="preload" href="/whg-training-resources/assets/js/runtime~main.8fe67747.js" as="script">
<link rel="preload" href="/whg-training-resources/assets/js/main.91c67f1f.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/whg-training-resources/"><div class="navbar__logo"><img src="/whg-training-resources/img/wchg.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/whg-training-resources/img/wchg-white.png" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title text--truncate">Training Resources</b></a><a class="navbar__item navbar__link" href="/whg-training-resources/overview/">Tutorials home</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/whg-training/whg-training-resources" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_dLyj"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper docsWrapper_mKqt"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_RiI4" type="button"></button><div class="docPage_ualW"><aside class="theme-doc-sidebar-container docSidebarContainer_UQUJ"><div class="sidebar_RiAD"><nav class="menu thin-scrollbar menu_izAj"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/whg-training-resources/statistical_modelling/introduction/">Introduction to statistics for genomics</a><button aria-label="Toggle the collapsible sidebar category &#x27;Introduction to statistics for genomics&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/whg-training-resources/statistical_modelling/probability_cheatsheet/">Probability cheatsheet</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/whg-training-resources/statistical_modelling/regression_modelling/">Statistical modelling I - regression</a><button aria-label="Toggle the collapsible sidebar category &#x27;Statistical modelling I - regression&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/whg-training-resources/statistical_modelling/">Statistical modelling</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/whg-training-resources/statistical_modelling/Hidden_markov_models/">Glycophorin CNV calling tutorial</a><button aria-label="Toggle the collapsible sidebar category &#x27;Glycophorin CNV calling tutorial&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_warmup/">Warmup: examining read coverage in a region</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_hmm/">Modelling CNVs using a Hidden Markov Model</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/whg-training-resources/statistical_modelling/notes/computing_pvalues/">notes</a></div></li></ul></nav></div></aside><main class="docMainContainer_uL0j"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_DM6M"><div class="docItemContainer_vinB"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Xlws" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/whg-training-resources/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_kU5B"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/whg-training-resources/statistical_modelling/Hidden_markov_models/"><span itemprop="name">Glycophorin CNV calling tutorial</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Modelling CNVs using a Hidden Markov Model</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_bZGK theme-doc-toc-mobile tocMobile_TmEX"><button type="button" class="clean-btn tocCollapsibleButton_l22C">On this page</button></div><div class="theme-doc-markdown markdown"><h1>Modelling CNVs using a Hidden Markov Model</h1><p><strong> !! Note !! </strong> To run this part of the practical, you first need to have computed a set of log-likelihoods for
each sample at each site in the relevant dataset. The code to do this was explained in the
<a href="/whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_warmup/">warmup tutorial</a>, which you can also find in this directory.</p><p>If you haven&#x27;t run it in this R session, please run this now:</p><div class="language-R codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-R codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">    source( &#x27;glycophorin_cnv_warmup_code.R&#x27; )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You should now have the data (<code>X</code>, <code>sites</code>, <code>samples</code>) loaded, and you should have a 532 x 200 x 6 array called <code>copy.number.lls</code> loaded.  Check by writing:</p><div class="language-R codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-R codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">    View( copy.number.lls )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>You should see a bunch of (mostly large and negative) numbers.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-forward-backward-algorithm">The forward-backward algorithm<a class="hash-link" href="#the-forward-backward-algorithm" title="Direct link to heading">​</a></h2><p>The forward.backward() function implements (guess what?) the HMM forward-backward algorithm based on arrays of emission
and transition probabilities, and the prior. First, the alpha and beta values (forward and backward algorithm
probabilities) are computed. Then, the two are combined to compute state probabilities (gamma) at each site.</p><p>These computations and notation are all as in the Rabiner HMM tutorial:
<a href="https://web.ece.ucsb.edu/Faculty/Rabiner/ece259/Reprints/tutorial%20on%20hmm%20and%20applications.pdf" target="_blank" rel="noopener noreferrer">https://web.ece.ucsb.edu/Faculty/Rabiner/ece259/Reprints/tutorial%20on%20hmm%20and%20applications.pdf</a></p><p>The only complication is that to avoid numerical over/underflow we work in log space, so have to change expressions
accordingly. Multiplications get converted to additions in log space.  But to avoid numerical issues, <em>additions</em> of
probabilities are best converted by using the <code>log.sum.exp()</code> function (that should already be loaded), rather than
using <code>log( sum( exp()))</code> directly.</p><div class="language-R codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-R codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain"># a generally useful function:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">echo &lt;- function( message, ... ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    cat( sprintf( message, ... ))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">forward.backward &lt;- function(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    emissions,              # matrix of emission log-probabilities (LxD)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transitions,       # (L-1)xDxD array of transition probabilities into each bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    prior                  # vector of prior state probabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # FORWARD ALGORITHM</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    forward = function( emissions, transitions, prior ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        L = nrow(emissions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        D = ncol(transitions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        alpha = matrix( 0, nrow = L, ncol = D )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # 1. Initialisation</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # alpha_1 gets initialised from prior and observations multiplied.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # (Multiplied probabilities, but we are working in log space so add them)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        alpha[1,] = emissions[1,] + prior</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # alpha_n+1 is obtained by summing over states i at time n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # In non-log-space this would be:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #          ( sum_i alpha[n,i] * transitions[n,i,j] ) * emissions[n,j]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # But in log space it is instead:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #   alpha[n+1,j] = logsumexp_i(alpha[n,i] + transitions[n,i,j]) + emissions[n,j]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for( n in 1:(L-1)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for( j in 1:D ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                alpha[n+1,j] = log.sum.exp( alpha[n,] + transitions[n,,j] ) + emissions[n+1,j]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return( alpha )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    backward &lt;- function( emissions, transitions ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        L = nrow(emissions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        D = ncol(transitions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        beta = matrix( 0, nrow = L, ncol = D )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Initialisation, initialise to prob = 1 (or log prob = 0)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        beta[L,] = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Usually</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # beta_n is obtained by summing over states j at time n+1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #   sum_j transitions[n,i,j] * emissions[n+1,j] * beta[n+1,j]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # but in log space it is instead:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        #   logsumexp_j( transitions[n,i,j] + emissions[n+1,j] + beta[n+1,j] )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        for( n in (L-1):1 ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            for( i in 1:D ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                beta[n,i] = log.sum.exp( transitions[n,i,] + emissions[n+1,] + beta[n+1,] )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        return( beta )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    L = nrow(emissions)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    copy.numbers = 0:(length(prior)-1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Posterior state probabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    alpha = forward( emissions, transitions, prior )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    beta = backward( emissions, transitions )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Posterior state probabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    gamma = alpha + beta - log.sum.exp( alpha[L,] )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        list(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            emissions = emissions,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            alpha = alpha,  # Forward log-probabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            beta = beta,    # Backward log-probabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            gamma = gamma # Marginal log-probabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    ) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Sanity checks:</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 1: rowSums( exp( gamma )) == 1, marginal probalities sum to one</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # 2: rowSums( exp( alpha + beta )) should all be equal (total observation probability)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="computing-transition-probabilities">Computing transition probabilities<a class="hash-link" href="#computing-transition-probabilities" title="Direct link to heading">​</a></h2><p>To define transition probabilities, we&#x27;ll assume a model of exponential copy number tract length with expected length
controlled by a rate parameter <code>lambda</code>.  </p><p>We also pass in a list of between-site distances, but in our example all bins are the same size, so we will just pass
in a list of 1s and interpret parameters accordingly.  In other words, <code>lambda=1</code> would correspond to an expected tract length of 1600bp.</p><div class="language-R codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-R codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain"># compute.transitions() returns an array of transition log-probabilities</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># This is arranged so that, if tp is the result then</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># tp[n,i,j] is the log-probability of transitioning from state i to state j at position n</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">compute.transitions &lt;- function(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    distances,      # distance between points</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lambda,         # &#x27;switchiness&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    prior           # prior state log-probabilities </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Given distance d, probability of switching</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # to a new state is 1 - e^-lambda d</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # (This starts at 0 when d = 0 and increases to 1 when d is large).</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # If switching we pick a new state from the prior.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # (NB. this implies the chain is stationary.)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # We work in log space so convert expressions accordingly</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    D = length( prior )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = array(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        NA,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dim = c(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            length( distances ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            D,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for( n in 1:length(distances)) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        distance = distances[n]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        scaled.prior = prior + log( 1 - exp( -lambda * distance ))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result[n,,] = matrix(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            rep( scaled.prior, D ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            byrow = T,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            nrow = D,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            ncol = D</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # Probability of no switch is e^-lambda d</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        diag( result[n,,] ) = rep( -lambda * distance, D )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Note: (exponentiated) rows now sum to one because prior sums to 1.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return( result )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="the-copy-number-hmm">The Copy number HMM<a class="hash-link" href="#the-copy-number-hmm" title="Direct link to heading">​</a></h2><p>The next function puts this all together to implement the CNV-finding HMM.
It takes:</p><ul><li>a matrix of per-site, per-sample copy number logliklihoods to be used as emission probabilities.</li><li>prior probabilities for each copy number state</li><li>and a lambda used to determine expected length of transition</li></ul><p>It also takes a last parameter (<code>site.multipliers</code>) that can used to control for per-site variation, but we&#x27;re not using it here.</p><div class="language-R codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-R codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain"># Function cnv.hmm()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Implement one iteration of the CNV-finding HMM for a matrix of N samples and L sites (bins)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">#</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># Return value is a list with several members</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># - `prior` is the copy number prior, as passed in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># - `marginal.log.probabilities` are the the log-posterior probabilities of each copy number given the HMM (i.e. gamma in the HMM)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># - `expected.copy.numbers` are the expected copy numbers at each site, given the posteriors.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># - `emission.log.probabilities` the matrix of copy number lls, as passed in</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"># The total log-probability across all samples (this is the total log-likelihood of our model)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cnv.hmm &lt;- function(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    copy.number.lls,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    prior,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lambda,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    site.multipliers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # sanity checks</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    stopifnot( dim( copy.number.lls )[3] == length( prior ))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Get a list of samples</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    samples = dimnames(copy.number.lls)[[2]]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    N = length( samples )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    L = nrow( copy.number.lls) # number of sites</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo( &quot;Running HMM for %d samples at %d sites...\n&quot;, N, L )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # prior is assumed to be for copy number states 0 ... K</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    copy.numbers = 0:(length(prior)-1)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    log.prior = log( prior )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    result = list(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        prior = prior,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # This array reports the posterior probability of each</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # copy number state at each site for each sample</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        # under the HMM model</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        marginal.log.probabilities = array(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            NA,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dim = c( N, L, length( copy.numbers )),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dimnames = list(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                samples,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rownames( copy.number.lls ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                sprintf( &quot;cn=%d&quot;, copy.numbers )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        expected.copy.numbers = array(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            NA,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dim = c( L, N ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            dimnames = list(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                rownames(copy.number.lls ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                samples</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emission.log.probabilities = copy.number.lls,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        total.log.probability = 0</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    transitions = compute.transitions( rep( 1, L-1 ), lambda, log.prior )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    for( i in 1:N ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        emissions = copy.number.lls[,i,]</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        fb = forward.backward( emissions, transitions, log.prior )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result$total.log.probability = result$total.log.probability + log.sum.exp( fb$alpha[1,] + fb$beta[1,] )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result$marginal.log.probabilities[i,,] = fb$gamma</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        result$expected.copy.numbers[,i] = exp(fb$gamma) %*% copy.numbers</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        echo( &quot;.&quot; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        if( i %% 50 == 0 ) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            echo( &quot;\n&quot; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    echo( &quot;\nok\n&quot; )</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return( result ) ;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="run-the-hmm">Run the HMM<a class="hash-link" href="#run-the-hmm" title="Direct link to heading">​</a></h2><p>Ok we are ready to run!  Let&#x27;s set it going:</p><div class="language-R codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-R codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">result = cnv.hmm(</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Copy number log-likelihoods computed earlier.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    copy.number.lls,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Prior on each copy number state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # States are assumed to start at zero (no copies) and go up to K</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Here we put 90% prior on diploid state</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    prior = c( 0.02, 0.02, 0.9, 0.02, 0.02, 0.02 ),</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # lambda = switch rate per bin</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Each bin is 1600bp, so 1/10 expects 1 switch every 16kb and so on</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    lambda = 1/20,</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # site multipliers affect values across samples for each site</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # these could be used to handle variation in coverage e.g. due to site-specific</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # mapping, sequence data rates, GC content etc.</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    # Here we set these all to 1 for an initial run</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    site.multipliers = rep( 1, nrow( X ))</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plot.copy.numbers( result$expected.copy.number, title = &quot;Expected copy number (HMM model)&quot; )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>Compare this with the previous plot based only on per-site coverage values for each sample - the new plot is much cleaner.  Also let&#x27;s cluster samples again:</p><div class="language-R codeBlockContainer_MPoW theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_B9tL"><pre tabindex="0" class="prism-code language-R codeBlock__0OG thin-scrollbar"><code class="codeBlockLines_gEuF"><span class="token-line" style="color:#393A34"><span class="token plain">o = hclust( # hierarchical clustering</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        dist( t(result$expected.copy.number) ) # of Euclidean distance matrix between samples</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">)$order</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">plot.copy.numbers( result$expected.copy.number[,o], title = &quot;Expected copy number (HMM model, clustered)&quot; )</span><br></span></code></pre><div class="buttonGroup_hRr1"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_W9eQ" aria-hidden="true"><svg class="copyButtonIcon_XEyF" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_i9w9" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><h2 class="anchor anchorWithStickyNavbar_mojV" id="further-directions">Further directions<a class="hash-link" href="#further-directions" title="Direct link to heading">​</a></h2><p>Our model is getting better but there are lots of things we could do to improve this!</p><p>First, there&#x27;s variation between sites e.g. sequence coverage variation due to genome GC content or mapping performance.
We could try to control for this by iteravely fitting per-site multipliers in the above (maybe using MCMC or another algorithm).</p><p>Second, having taken a first call of what the CNVs are, we now have more information to estimat ethe Gaussian parameters!  So we could go back and re-estimate, and iterate.</p><p>There are lots of other ways this model could be improved - challenge is to think of some.</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/whg-training/whg-training-resources/edit/main/docs/statistical_modelling/Hidden_markov_models/glycophorin_cnv_hmm.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_dcUD" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_foO9"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/whg-training-resources/statistical_modelling/Hidden_markov_models/glycophorin_cnv_warmup/"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Warmup: examining read coverage in a region</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/whg-training-resources/statistical_modelling/notes/computing_pvalues/"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Asymptotics and  P-values</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_cNA8 thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#the-forward-backward-algorithm" class="table-of-contents__link toc-highlight">The forward-backward algorithm</a></li><li><a href="#computing-transition-probabilities" class="table-of-contents__link toc-highlight">Computing transition probabilities</a></li><li><a href="#the-copy-number-hmm" class="table-of-contents__link toc-highlight">The Copy number HMM</a></li><li><a href="#run-the-hmm" class="table-of-contents__link toc-highlight">Run the HMM</a></li><li><a href="#further-directions" class="table-of-contents__link toc-highlight">Further directions</a></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">License</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/whg-training-resources/LICENSE/">License</a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/whg-training/whg-training-resources" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_I5OW"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 University of Oxford.  Built with Docusaurus.</div></div></div></footer></div>
<script src="/whg-training-resources/assets/js/runtime~main.8fe67747.js"></script>
<script src="/whg-training-resources/assets/js/main.91c67f1f.js"></script>
</body>
</html>