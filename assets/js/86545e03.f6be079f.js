"use strict";(self.webpackChunkwhg_training_resources=self.webpackChunkwhg_training_resources||[]).push([[1205],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>g});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var r=a.createContext({}),p=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(r.Provider,{value:t},e.children)},u="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,r=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=p(n),c=i,g=u["".concat(r,".").concat(c)]||u[c]||h[c]||o;return n?a.createElement(g,s(s({ref:t},m),{},{components:n})):a.createElement(g,s({ref:t},m))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,s=new Array(o);s[0]=c;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l[u]="string"==typeof e?e:i,s[1]=l;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5930:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),i=(n(7294),n(3905));const o={sidebar_position:1},s="Genetic drift",l={unversionedId:"population_genetics/simulation/popgen_simulation",id:"population_genetics/simulation/popgen_simulation",title:"Genetic drift",description:"The Wright-Fisher model is about the simplest population-genetic model there is.  It consists of:",source:"@site/docs/population_genetics/simulation/popgen_simulation.md",sourceDirName:"population_genetics/simulation",slug:"/population_genetics/simulation/popgen_simulation",permalink:"/whg-training-resources/population_genetics/simulation/popgen_simulation",draft:!1,editUrl:"https://github.com/whg-training/whg-training-resources/edit/main/docs/population_genetics/simulation/popgen_simulation.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"sidebar7",previous:{title:"Simulating populations",permalink:"/whg-training-resources/population_genetics/simulation/"},next:{title:"Adding mutations",permalink:"/whg-training-resources/population_genetics/simulation/mutations"}},r={},p=[{value:"Getting started",id:"getting-started",level:2},{value:"Generating a starting set of haplotypes",id:"generating-a-starting-set-of-haplotypes",level:3},{value:"Generating a population",id:"generating-a-population",level:3},{value:"Evolving the population",id:"evolving-the-population",level:2},{value:"How frequencies evolve",id:"how-frequencies-evolve",level:3},{value:"How linkage disequilibrium evolves",id:"how-linkage-disequilibrium-evolves",level:3},{value:"Exploring the simulations.",id:"exploring-the-simulations",level:3},{value:"Next steps",id:"next-steps",level:2}],m={toc:p},u="wrapper";function h(e){let{components:t,...o}=e;return(0,i.kt)(u,(0,a.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"genetic-drift"},"Genetic drift"),(0,i.kt)("p",null,"The Wright-Fisher model is about the simplest population-genetic model there is.  It consists of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A population of ",(0,i.kt)("em",{parentName:"li"},"N")," individuals (which stays fixed over time)."),(0,i.kt)("li",{parentName:"ul"},"non-overlapping generations"),(0,i.kt)("li",{parentName:"ul"},"in each generation, each individual 'samples' its parent uniformly from individuals in the parent generation.")),(0,i.kt)("p",null,"It's pretty simple to implement, but even so it turns out to have many of the key features of real populations. We are going\nto implement it."),(0,i.kt)("h2",{id:"getting-started"},"Getting started"),(0,i.kt)("p",null,"As stated above there isnt really anything about ",(0,i.kt)("em",{parentName:"p"},"genetics")," in the model. So to give ourselves some genetic data to work with,\nwe'll also generate a set of haplotypes and have them evolve through the model."),(0,i.kt)("p",null,"Let's get started."),(0,i.kt)("h3",{id:"generating-a-starting-set-of-haplotypes"},"Generating a starting set of haplotypes"),(0,i.kt)("p",null,"Let's imagine we are looking at set of ",(0,i.kt)("em",{parentName:"p"},"L = 20")," SNPs to start with and that there are (say) up to 10 different haplotypes in our population at the start of the simulation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"L = 20\nH = 10\nhaplotypes = matrix( NA, nrow = H, ncol = L )\n")),(0,i.kt)("p",null,"To generate some simple haplotypes to look at, let's take a simple situation in which the variants are all biallelic (we'll encode the alleles as ",(0,i.kt)("inlineCode",{parentName:"p"},"0")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"1"),"), they all start off independent of each other, and they all have 20% frequency.  We can simulate using ",(0,i.kt)("inlineCode",{parentName:"p"},"rbinom()")," like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"haplotypes[,] = rbinom( n = H*L, size = 1, prob = 0.2 )\n")),(0,i.kt)("p",null,"Here's function to make a quick plot of our starting haplotypes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'plot.haplotypes <- function( haplotypes ) {\n  image(\n    t(haplotypes),\n    x = 1:ncol(haplotypes),\n    y = 1:nrow(haplotypes),\n    xlab = "variant",\n    ylab = "haplotype"\n  )\n}\n')),(0,i.kt)("p",null,"If you call it"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"plot.haplotypes( haplotypes )\n")),(0,i.kt)("p",null,"You should see something like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img",src:n(2764).Z,width:"300",height:"200"})),(0,i.kt)("h3",{id:"generating-a-population"},"Generating a population"),(0,i.kt)("p",null,"We will now generate a set of ",(0,i.kt)("em",{parentName:"p"},"N")," (haploid) individuals each of whom has one of the starting haplotypes. To keep track of the\nevolution over ",(0,i.kt)("em",{parentName:"p"},"G")," generations, let's record these haplotypes in the first row of a matrix:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'N = 100 # number of individuals\nG = 100 # number of generations\npopulation = matrix(\n  NA, nrow = G, ncol = N,\n  dimnames = list(\n    sprintf( "generation=%d", 1:G ),\n    sprintf( "individual=%d", 1:N )\n  )\n)\n')),(0,i.kt)("p",null,"To generate our starting population let's randomly sample our generated haplotypes for the first generation:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"population[1,] = sample( 1:H, size = N, replace = TRUE )\n")),(0,i.kt)("p",null,"Now we can plot what our population looks like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"plot.haplotypes( haplotypes[population[1,],] )\n")),(0,i.kt)("p",null,"Which should show something like this:"),(0,i.kt)("p",null,"![img]","(/Population genetics/solutions/initial_population.png)"),(0,i.kt)("h2",{id:"evolving-the-population"},"Evolving the population"),(0,i.kt)("p",null,"In the Wright-Fisher model, in each generation, each individual samples its haplotype from a randomly chosen parent in the generation before.  Let's write a function to generate a new generation given the current one (a row of ",(0,i.kt)("inlineCode",{parentName:"p"},"population"),"):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"evolve <- function( currentGeneration ) {\n  parents = sample( 1:N, size = N, replace = TRUE )\n  return( currentGeneration[parents] )\n}\n")),(0,i.kt)("p",null,"That was pretty easy!  Now we can evolve the population:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"for( generation in 2:G ) {\n  population[generation,] = evolve( population[generation-1,] )\n}\n")),(0,i.kt)("p",null,"Look at the result before and after evolution:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"layout( matrix( 1:2, nrow = 2 ) )\npar( mar = c( 3, 3, 1, 1 ))\nplot.haplotypes( haplotypes[population[1,],])\nplot.haplotypes( haplotypes[population[G,],])\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Question.")," What features of this do you notice?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note.")," It might be worth emphasising here that there is nothing going on in our model except\ninheritance - i.e. genetic drift.  Any structure that appears is purely due to random inheritance."),(0,i.kt)("h3",{id:"how-frequencies-evolve"},"How frequencies evolve"),(0,i.kt)("p",null,"If you look at the 'before' and 'after' haplotypes, you'll probably see some features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"many variants are no longer polymorphic - the other alleles have been 'lost' or have 'fixed'"),(0,i.kt)("li",{parentName:"ul"},"many of the remaining alleles are either rare or common.")),(0,i.kt)("p",null,"But how do these evolve over time? To see that let's write some quick functions to compute the haplotype and variant frequencies across time:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'compute.haplotype.frequencies <- function( population, haplotypes ) {\n  # We compute the frequency of each variant at each generation\n  result = matrix(\n    nrow = G,\n    ncol = H,\n    dimnames = list(\n      sprintf( "generation=%d", 1:G ),\n      sprintf( "haplotype=%d", 1:H )\n    )\n  )\n  for( i in 1:G ) {\n    currentGeneration = population[i,]\n    result[i,] = sapply( 1:H, function(h) { length( which( currentGeneration == h )) } ) / N\n  }\n  return( result )\n}\n')),(0,i.kt)("p",null,"And plot them:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"blank.plot <- function( xlim = c( 0, 1 ), ylim = c( 0, 1 ), xlab = \"\", ylab = \"\" ) {\n  # this function plots a blank canvas\n  plot(\n    0, 0,\n    col = 'white', # draw points white\n    bty = 'n',     # no border\n    xaxt = 'n',    # no x axis\n    yaxt = 'n',    # no y axis\n    xlab = xlab,   # no x axis label\n    ylab = ylab,   # no x axis label\n    xlim = xlim,\n    ylim = ylim\n  )\n}\n\nfrequencies = compute.haplotype.frequencies( population, haplotypes )\n\nblank.plot( xlim = c( 1, G ), ylim = c( 0, 1 ), xlab = \"Generations\", ylab = \"Haplotype frequencies\")\npalette = rainbow( H )\nfor( i in 1:H ) {\n  points( 1:G, frequencies[,i], col = palette[i], type = 'l' )\n}\ngrid()\naxis(1)\naxis(2)\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Question.")," What happens to the haplotype frequencies over time?  What is causing this?"),(0,i.kt)("h3",{id:"how-linkage-disequilibrium-evolves"},"How linkage disequilibrium evolves"),(0,i.kt)("p",null,"Because all our SNPs were independent of each other, and all the samples were unrelated, we\nwouldn't expect to see any strong linkage disequilibrium (correlation between genotypes at\ndifferent variants) at the start of our simulation. Or do we? Let's compute the LD now and see:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"compute.ld <- function( haplotypes ) {\n  cor( haplotypes )\n}\n\ncompute.ld( haplotypes[population[1,],] )\n")),(0,i.kt)("p",null,"You should get a big 20x20 matrix of correlation values, with ones on the diagonal and lower values between SNPs.  The ",(0,i.kt)("inlineCode",{parentName:"p"},"image()")," function can be used to visualise this.  By default ",(0,i.kt)("inlineCode",{parentName:"p"},"image()")," chooses its own colour set, but we'll specify a fixed set using the ",(0,i.kt)("inlineCode",{parentName:"p"},"breaks")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"col")," arguments:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"\nplot.ld <- function( haplotypes ) {\n  breaks = c( -0.01, seq( from = 0.1, to = 1, by = 0.1 ))\n  ld.colours = c( 'grey95', rev( heat.colors( length(breaks)-2 )))\n  r = compute.ld( haplotypes )\n  image(\n    r^2,\n    breaks = breaks,\n    col = ld.colours\n  )\n}\nplot.ld( haplotypes[population[1,],])\n")),(0,i.kt)("p",null,"Here we've plotted ",(0,i.kt)("em",{parentName:"p"},"r",(0,i.kt)("sup",null,"2")),"; the colour scale is set up so ",(0,i.kt)("em",{parentName:"p"},"red points")," are variants in high LD (also seen on the diagonal); yellow & orange points have intermediate LD; and grey points have ",(0,i.kt)("em",{parentName:"p"},"r",(0,i.kt)("sup",null,"2")," < 0.1"),".  And white points have missing values (which occurs if one or other of the variants was actually monomorphic.)  It should look something like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img",src:n(4951).Z,width:"400",height:"300"})),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note.")," As it turns out, even at this starting point in our simulation, there can be a bit of LD.\nIt arises due to our finite set of starting haplotypes."),(0,i.kt)("p",null,"Now plot the LD for the final generation and compare to the original:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"layout( matrix( 1:2, ncol = 1 ))\nplot.ld( haplotypes[population[1,],] )\nplot.ld( haplotypes[population[G,],] )\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Question.")," What do you see?"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note.")," Depending on your simulation, you ",(0,i.kt)("em",{parentName:"p"},"might")," see patterns emerging.  On the other hand, you might just see lots of white (missing) LD - it depends what happened in the simulation.)"),(0,i.kt)("h3",{id:"exploring-the-simulations"},"Exploring the simulations."),(0,i.kt)("p",null,"In the file ",(0,i.kt)("a",{target:"_blank",href:n(8487).Z},(0,i.kt)("code",null,"simulation_and_visualisation.R")),"\n(also available ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/whg-training/whg-training-resources/blob/main/docs/population_genetics/simulation_and_visualisation.R"},"on github"),")\nI've wrapped up the above code into two key functions:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"simulate.population()")," which simulates from the model as above."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"plot.simulation()")," which makes a multi-panel plot of the result.")),(0,i.kt)("p",null,"To get this code, ",(0,i.kt)("inlineCode",{parentName:"p"},"source()")," it into your session:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'source( "simulation_and_visualisation.R" )\n')),(0,i.kt)("p",null,"You can run it like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"sim = simulate.population( L = 20, N = 100, G = 100 )\nplot.simulation(sim)\n")),(0,i.kt)("p",null,"or on one line:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"plot.simulation( simulate.population( L = 20, N = 100, G = 100 ) )\n")),(0,i.kt)("p",null,"It produces a plot like this:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img",src:n(1962).Z,width:"500",height:"600"})),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Questions")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},"Explore the simulations and try varying the parameters. In particular, how does varying the population size ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"N")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N")))))," affect the\nsimulations?")),(0,i.kt)("p",{parentName:"div"},(0,i.kt)("strong",{parentName:"p"},"Note.")," Remember that ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"L")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"L")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"L")))))," is the number of variants, ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"N")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N")))))," is the population size, and ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"G")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"G")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"G")))))," is the number of generations. (You\ncan also specify ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"H")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"H")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6833em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.08125em"}},"H"))))),", the number of different haplotypes we created at the simulation start, if you want to.)"),(0,i.kt)("ul",{parentName:"div"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Describe in general what happens to haplotypes and variants as the simulations proceed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"What does genetic drift do to LD?"))))),(0,i.kt)("h2",{id:"next-steps"},"Next steps"),(0,i.kt)("p",null,"Next let's look at some ",(0,i.kt)("a",{parentName:"p",href:"/whg-training-resources/population_genetics/simulation/statistics"},"key population genetic statistics"),"."))}h.isMDXComponent=!0},8487:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/simulation_and_visualisation-60b89c36cb32eb5f3d0a7a2a013d9006.R"},2764:(e,t,n)=>{n.d(t,{Z:()=>a});const a="data:image/png;base64,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"},4951:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/ld-02d64324ec78a2a413ba4954d6cd4dbb.png"},1962:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/simulation-6476da8b1dc80b7e7ea849d374bdd628.png"}}]);