"use strict";(self.webpackChunkwhg_training_resources=self.webpackChunkwhg_training_resources||[]).push([[3488],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=o,d=u["".concat(l,".").concat(h)]||u[h]||c[h]||i;return n?a.createElement(d,r(r({ref:t},m),{},{components:n})):a.createElement(d,r({ref:t},m))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,r[1]=s;for(var p=2;p<i;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},3832:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),o=(n(7294),n(3905));const i={sidebar_position:2},r="Adding mutations",s={unversionedId:"population_genetics/simulation/mutations",id:"population_genetics/simulation/mutations",title:"Adding mutations",description:"So, genetic drift causes loss of haplotypes from the population and generates LD.",source:"@site/docs/population_genetics/simulation/mutations.md",sourceDirName:"population_genetics/simulation",slug:"/population_genetics/simulation/mutations",permalink:"/whg-training-resources/population_genetics/simulation/mutations",draft:!1,editUrl:"https://github.com/whg-training/whg-training-resources/edit/main/docs/population_genetics/simulation/mutations.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"sidebar7",previous:{title:"Genetic drift",permalink:"/whg-training-resources/population_genetics/simulation/popgen_simulation"},next:{title:"Some population-genetic statistics",permalink:"/whg-training-resources/population_genetics/simulation/statistics"}},l={},p=[{value:"Starting over",id:"starting-over",level:2},{value:"Sorting haplotypes",id:"sorting-haplotypes",level:2},{value:"Implementing mutations",id:"implementing-mutations",level:2},{value:"Watching it run",id:"watching-it-run",level:2},{value:"Assessing diversity",id:"assessing-diversity",level:2}],m={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"adding-mutations"},"Adding mutations"),(0,o.kt)("p",null,"So, genetic drift causes loss of haplotypes from the population and generates LD.\nIf this was all that was going on, we'd all be identical!"),(0,o.kt)("p",null,"Of course in real populations there is an opposing force: ",(0,o.kt)("strong",{parentName:"p"},"mutation"),".  To see how this plays out let's add mutations to our model now."),(0,o.kt)("h2",{id:"starting-over"},"Starting over"),(0,o.kt)("p",null,"Let's build our simulation again, and this time let's give ourselves a long stretch of chromosome to work over - say\n5kb. As before we'll initialise the simulation with a set of 10 possible haplotypes:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"L = 5000\nH = 10\nhaplotypes = matrix( NA, nrow = H, ncol = L )\nhaplotypes[,] = rbinom( n = H*L, size = 1, prob = 0.01 )\n")),(0,o.kt)("p",null,"Now let's pick a population size and initialise the simulation - for a first go I will pick 250 samples over 1000\ngenerations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},'N = 250 # number of individuals\nG = 500 # number of generations\npopulation = matrix(\n  NA, nrow = G, ncol = N,\n  dimnames = list(\n    sprintf( "generation=%d", 1:G ),\n    sprintf( "individual=%d", 1:N )\n  )\n)\n')),(0,o.kt)("p",null,"And let's initialise our population:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"population[1,] = sample( 1:nrow(haplotypes), N, replace = TRUE )\n")),(0,o.kt)("p",null,"As before we can plot the haplotypes in our population:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"plot.haplotypes( haplotypes[population[1,],] )\n")),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"You could also pick larger sample sizes above (especially if you have a fast computer!  This simulation is pretty slow.)\nHowever, I'd advise not to go above around 500 though - 200 or 250 would be a good try."))),(0,o.kt)("h2",{id:"sorting-haplotypes"},"Sorting haplotypes"),(0,o.kt)("p",null,"Let's immediately make a couple of tweaks here. First, it would be nicer to sort the haplotypes before plotting.  Second, so we can easily compare different population sizes, let's just have it plot the first 100 samples.  Here is a function that can do that:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"plot.haplotypes <- function(\n    haplotypes,\n    sort = FALSE,\n    number_to_plot = 100\n) {\n  # We just plot the 'sample' of the first n\n  n = min(number_to_plot, nrow(haplotypes))\n  haplotypes = haplotypes[1:n,]\n  if( sort ) {\n    # We use 'hierarchical clustering' to order the haplotypes\n    # We are here using 'manhattan' distance, i.e. the sum of differences\n    # between pairs of haplotypes\n    order = hclust(\n        dist( haplotypes, method = \"manhattan\" )\n    )$order\n  } else {\n    order = 1:nrow(haplotypes)\n  }\n  image(\n    t(haplotypes[order,]),\n    x = 1:ncol(haplotypes),\n    y = 1:nrow(haplotypes),\n    xlab = \"variant\",\n    ylab = \"haplotype\"\n  )\n}\n\nplot.haplotypes( haplotypes[population[1,],], sort = TRUE )\n")),(0,o.kt)("p",null,"Ok this looks nice!"),(0,o.kt)("h2",{id:"implementing-mutations"},"Implementing mutations"),(0,o.kt)("p",null,"Our ",(0,o.kt)("inlineCode",{parentName:"p"},"evolve()")," function is pretty simple at the moment - it looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"evolve <- function( currentGeneration ) {\n  parents = sample( 1:N, size = N, replace = TRUE )\n  return( currentGeneration[parents] )\n}\n")),(0,o.kt)("p",null,"Let's update it to account for mutations.  "),(0,o.kt)("p",null,"This takes a bit of care because of the way we have set our simulation up -  using the  ",(0,o.kt)("inlineCode",{parentName:"p"},"haplotypes")," matrix to keep track of the actual alleles on each haplotype.  To do this, let's create a ",(0,o.kt)("inlineCode",{parentName:"p"},"mutate()")," function which:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"reads in the index of a current haplotype"),(0,o.kt)("li",{parentName:"ol"},"mutates it at a single site, and"),(0,o.kt)("li",{parentName:"ol"},"adds the new mutant haplotype to the list of haplotypes:")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"mutate <- function( which_haplotype ) {\n  # Take an existing haplotype...\n  old_haplotype = haplotypes[which_haplotype,]\n\n  # mutate it at a single site\n  new_haplotype = old_haplotype\n  w = sample( 1:L, 1 )\n  new_haplotype[w] = 2\n\n  # Add it to our list and return the index.\n  haplotypes <<- rbind( haplotypes, new_haplotype )\n  return( nrow( haplotypes ))\n}\n")),(0,o.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"Note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"The syntax ",(0,o.kt)("inlineCode",{parentName:"p"},"<<-")," is important here!  We are using this to alter the global ",(0,o.kt)("inlineCode",{parentName:"p"},"haplotypes")," variable.  In general, using a global variable like this is ",(0,o.kt)("strong",{parentName:"p"},"bad programming practice"),", but it will work for our simulation so we're going with for the moment..."))),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"Most entries of the haplotypes are 0 or 1, but in ",(0,o.kt)("inlineCode",{parentName:"p"},"mutate()")," I chose to mutate to a value of 2!  The reason for this is that these new mutations will appear a different colour on our output plots, so we can easily see the effect of mutations on the population"))),(0,o.kt)("p",null,"If you call ",(0,o.kt)("inlineCode",{parentName:"p"},"mutate()"),", say like this: ",(0,o.kt)("inlineCode",{parentName:"p"},"mutate(5)"),", you ought now to find that:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"haplotypes")," now has an extra row (row 11 presumably)."),(0,o.kt)("li",{parentName:"ul"},"the new row is the same as row 5, except for one mutation in it.`")),(0,o.kt)("p",null,"With mutations in place we can write an updated ",(0,o.kt)("inlineCode",{parentName:"p"},"evolve()")," function.  We will take in a ",(0,o.kt)("strong",{parentName:"p"},"mutation rate")," parameter and, after each inheritance takes place, randomly decide whether a mutation occurs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"\nevolve <- function(\n    currentGeneration,\n    mutation_rate_per_locus = 0.1\n) {\n  # Inherit from parents, as before\n  parents = sample( 1:N, size = N, replace = TRUE )\n  new = currentGeneration[parents]\n\n  # Now decide if any haplotypes should mutate...\n  who.mutates = which( rbinom( N, size = 1, prob = mutation_rate_per_locus ) == 1 )\n  # ...and mutate them:\n  for( i in who.mutates ) {\n    new[i] = mutate( new[i] )\n  }\n\n  return( new )\n}\n")),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"When talking about mutation rates, you have to decide if you are talking about mutation ",(0,o.kt)("strong",{parentName:"p"},"per locus")," (i.e. over the whole 5kb) or ",(0,o.kt)("strong",{parentName:"p"},"per site"),".  The function above is using the ",(0,o.kt)("strong",{parentName:"p"},"mutation rate per locus")," (so the rate per site is 1/5,000 times this.)"))),(0,o.kt)("h2",{id:"watching-it-run"},"Watching it run"),(0,o.kt)("p",null,"R is not great at making animated plots - instead let's aim to store the images on the filesystem.  We'll make a new folder for this now."),(0,o.kt)("p",null,"First make sure you are in the folder you want to be in for this practical, and let's make a place to store output images.  I'll keep the population size in the filename:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},'mutation_rate = 0.1\nimage_dir = sprintf( "simulation/N=%d,L=%d,mu=%.3f", N, L, mutation_rate )\ndir.create( image_dir, recursive = TRUE,  showWarnings = FALSE )\ndir.create( sprintf( "%s/haplotypes", image_dir), recursive = TRUE,  showWarnings = FALSE )\n')),(0,o.kt)("p",null,"Here is the useful ",(0,o.kt)("inlineCode",{parentName:"p"},"echo()")," function to print messages:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"echo = function( message, ... ) {\n  cat( sprintf( message, ... ))\n}\n")),(0,o.kt)("p",null,"And let's iterate:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},'for( generation in 2:G ) {\n  cat( sprintf( "generation %d of %d...\\n", generation, G ))\n\n  # Evolve the population, now with mutations\n  population[generation,] = evolve( population[generation-1,], mutation_rate )\n\n  # Let\'s just plot every 5th generation\n  if( generation %% 5 == 1 ) {\n    filename = sprintf( "%s/haplotypes/generation_%04d.png", image_dir, generation )\n    echo( "Plotting generation %d to \\"%s\\"...\\n", generation, filename )\n    png( file = filename, width = 1000, height = 400 )\n    plot.haplotypes( haplotypes[population[generation,],], sort = TRUE )\n    dev.off()\n  \n    # !! IMPORTANT!! Use gc() to return memory to operating system!\n    # Without this you may use up all your RAM\n    gc()\n  }\n}\n')),(0,o.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,o.kt)("div",{parentName:"div",className:"admonition-heading"},(0,o.kt)("h5",{parentName:"div"},(0,o.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,o.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,o.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"Note")),(0,o.kt)("div",{parentName:"div",className:"admonition-content"},(0,o.kt)("p",{parentName:"div"},"This will take a while to run."),(0,o.kt)("p",{parentName:"div"},"While it's going, point your operating system's image viewer at the output directory (",(0,o.kt)("inlineCode",{parentName:"p"},"image_dir"),") above to have a look at what's happening.  You should see your population evolving in real time!  Can you see the new mutations?"))),(0,o.kt)("h2",{id:"assessing-diversity"},"Assessing diversity"),(0,o.kt)("p",null,"Let's also implement two ways of measuring the amount of genetic diversity.  These are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("strong",{parentName:"p"},"average number of mutational differences between pairs of haplotypes"),", also known as the nucleotide diversity.  In popgen literature this is often denoted by ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mi",{parentName:"mrow"},"\u03c0")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\pi")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,o.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03588em"}},"\u03c0"))))),".")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"The ",(0,o.kt)("strong",{parentName:"p"},"average heterozygosity")," of the population, i.e. how likely are two randomly drawn alleles to be different?"))),(0,o.kt)("p",null,"Here are two functions to compute these quantities:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"compute.mean_number_of_pairwise_differences = function(\n    population,\n    haplotypes = haplotypes\n) {\n    generation = haplotypes[population,]\n    N = nrow(generation)\n    total = 0\n    for( i in 1:(N-1) ) {\n        for( j in (i+1):N ) {\n            a = generation[i,]\n            b = generation[j,]\n            total = total + sum( a != b )\n        }\n    }\n    return( total / (N*(N-1)/2))\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"compute.heterozygosity = function(\n    population\n) {\n    A = table(population)\n    n = sum(A)\n    result = 1\n    for( i in 1:length(A)) {\n        result = result - (A[i]/n) * ((A[i]-1)/(n-1))\n    }\n    return( result ) \n}\n")),(0,o.kt)("p",null,"Let's plot these for our simulation now.  We'll use the ",(0,o.kt)("inlineCode",{parentName:"p"},"layout()")," function to make a two-row plot:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-r"},"pi = sapply(\n  1:G,\n  function(i) {\n    compute.mean_number_of_pairwise_differences( population[i,] )\n  }\n)\n\nheterozygosity = sapply(\n  1:G,\n  function(i) {\n    compute.heterozygosity( population[i,] )\n  }\n)\n\n\nlayout( matrix( 1:2, ncol = 1 ))\nplot(\n    1:G,\n    pi,\n    xlab = \"Generation\",\n    ylab = \"Nucleotide diversity\",\n    bty = 'n',\n    type = 'l',\n    lwd = 2\n)\nabline( h = 2 * N * mutation_rate, lty = 2, col = 'red' )\ngrid()\nplot(\n    1:G,\n    heterozygosity,\n    xlab = \"Generation\",\n    ylab = \"Heterozygosity\",\n    bty = 'n',\n    type = 'l',\n    lwd = 2\n)\nabline( h = (2 * N * mutation_rate) / (2*N*mutation_rate + 1), lty = 2, col = 'red' )\ngrid()\n")))}c.isMDXComponent=!0}}]);